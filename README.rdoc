= EnumHelper

For columns in Rails models (or attributes in any class) this plugin provides
support for enumerated values including:

* defining constants
* defining predicate methods
* defining other constants
* defining other related methods
* specifying Rails <tt>validates_inclusion_of</tt> validation

Other enum-related plugins that might be a better fit for your needs:
* enum_field[http://github.com/jamesgolick/enum_field]
* enum_field[http://github.com/paraseba/enum_field]
* enumerated_attribute[http://github.com/jeffp/enumerated_attribute]
* enumlogic[http://github.com/binarylogic/enumlogic]

== Examples

=== Simplest Case

  class Person < ActiveRecord::Base
    enum_helper :sex, %w(male female)
  end

  # constants

  Person::SEXES       #=> ["male", "female"]
  Person::SEX_MALE    #=> "male"
  Person::SEX_FEMALE  #=> "female"

  guy = Person.new(:sex => SEX_MALE)  #=> #<Person id: nil, sex: "male">

  # predicate methods

  guy.sex_male?                     #=> true
  guy.sex_female?                   #=> false

  # validates_inclusion_of by default

  guy.valid?           #=> true
  guy.status = 'foo'
  guy.valid?           #=> false
  
  
=== Prefix

By default the singular constants and predicate methods use the field as a 
prefix.  You can specify a different prefix or <tt>:none</tt>.  You can also
specify the name of the plural constants (or let if default to the plural of prefix).

  class Person < ActiveRecord::Base
    enum_helper :sex, %w(male female), :prefix => 'gender'
    enum_helper :size, %w(small medium large), :prefix => :none
    enum_helper :hue, %w(red blue), :plural_constant_name => "COLORS"
  end

  person = Person.new(:sex => 'male', :size => 'small')  #=> #<Person id: nil, sex: "male", size: "small">
  
  Person::GENDER_MALE  #=> "male"
  person.gender_male?  #=> true

  Person::SMALL        #=> "small"
  person.large?        #=> false

  Person::COLORS       #=> ["red", "blue"]
  
=== Negated Predicate Methods

For every generated method <tt>foo?</tt>, a negated version <tt>not_foo?</tt> is generated:

  class Person < ActiveRecord::Base
    enum_helper :sex, %w(male female)
  end

  person = Person.new(:sex => 'male')
  
  person.sex_male?      #=> true
  person.sex_not_male?  #=> false

=== Related Methods

You can generate related methods and constants:

  class Person < ActiveRecord::Base
  
    enum_helper :sex, %w(boy girl unknown) do
      female? 'girl'
      KNOWN ['boy', 'girl']
    end
    
    enum_helper :size, ['small', 'medium', 'large', 'extra large'] do
      big? ['large', 'extra large']
    end
    
  end

  Person::SEX_KNOWN   #=> ['boy', 'girl']

  person = Person.new(:child => 'girl', :size => 'medium')

  person.sex_female?  #=> true
  person.size_big?    #=> false

If you want to reference a constant, instance variable, or instance method, pass a block:

  class Car < ActiveRecord::Base

    enum_helper :color, %w(red cherry green blue), :prefix => :none do
      REDS { [RED, CHERRY] }
      reddish? { REDS.include?(color) }
      reddish_and_old? { reddish? && age > 20 }
    end
  
  end

=== <tt>validates_inclusion_of</tt>

By default a subclass of ActiveRecord::Base will have its enum's validated.
You can prevent that by specifying <tt>:skip_validation => true</tt>:

  class Person < ActiveRecord::Base

    enum_helper :gender, %w(male female), :skip_validation => true

  end

You can pass options to +validates_inclusion_of+ by passing them as options to +enum_helper+:

  class Person < ActiveRecord::Base

    enum_helper :gender, %w(male female), :allow_blank => true, :message => 'must be "male" or "female"'

  end

=== Using with non-ActiveRecord Classes

The plugin automatically provides this support for subclasses of ActiveRecord.
Other classes will need to <tt>include EnumHelper</tt>:

  class Team  # not a subclass of ActiveRecord
    include EnumHelper
    
    enum_helper ...
  end
    
ActiveRecord <tt>validates_inclusion_of</tt> is skipped for non-ActiveRecord
classes regardless of the <tt>:skip_validation</tt> option.

== Tip

If you are having trouble figuring out what constants and methods are getting generated, try:

  MyClass.constants
  MyClass.new.methods

or if too much is returned:

  MyClass.constants.grep(/<search term>/i).sort
  MyClass.new.methods.grep(/<search term>/i).sort

== TODO

* support: not_foo? not 'foo'
* enum_select(:field)
* valid? / :allow_nil => true/false

== Copyright

Copyright (c) 2010 Steve Downey, released under the MIT license
